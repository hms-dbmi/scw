<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Scw2015 by JEFworks</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Scw2015</h1>
        <p>Single Cell Workshop 2015</p>

        <p class="view"><a href="https://github.com/JEFworks/scw2015">View the Project on GitHub <small>JEFworks/scw2015</small></a></p>


        <ul>
          <li><a href="https://github.com/JEFworks/scw2015/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/JEFworks/scw2015/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/JEFworks/scw2015">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="single-cell-workshop-2015" class="anchor" href="#single-cell-workshop-2015" aria-hidden="true"><span class="octicon octicon-link"></span></a>Single Cell Workshop 2015</h1>

<p>Materials for the <a href="http://hsci.harvard.edu/event/single-cell-genomics-workshops">Analysis of heterogeneity and subpopulations session of the HSCI/Catalyst single cell RNA-Seq workshop, Nov 2015</a></p>

<hr>

<h1>
<a id="analysis-of-heterogeneity-and-subpopulations" class="anchor" href="#analysis-of-heterogeneity-and-subpopulations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Analysis of heterogeneity and subpopulations</h1>

<p>In the last session of the workshop, we learned about the techniques that we can use to identify differentially expressed genes when we have two subpopulations of interest. Now, in this session, we will become familiar with a few computational techniques we can use to discover and characterize subpopulations using single cell RNA-seq data. </p>

<h1>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting started</h1>

<p>Be sure to have the appropriate modules loaded prior to starting analyses. </p>

<pre><code>module load dev/python/2.7.6
module load stats/R/3.2.1
</code></pre>

<p>A single cell dataset from <a href="http://www.nature.com/nbt/journal/v32/n10/abs/nbt.2967.html">Pollen et al.</a> has been pre-prepared for you. The data is provided as a matrix of gene counts, where each column corresponds to a cell and each row a gene. </p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># load and clean data</span>
load(<span class="pl-s"><span class="pl-pds">'</span>data_clean.RData<span class="pl-pds">'</span></span>)
<span class="pl-smi">cd</span>[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>]</pre></div>

<pre><code>##       Hi_NPC_1 Hi_NPC_10 Hi_NPC_14 Hi_NPC_15 Hi_NPC_13
## A1BG         0         0        29         0       174
## A2M          0         0        11         0        63
## A2MP1        0         0         0         0         0
## AAAS         0         0       106       182         7
## AACS         0         0         0       116         0
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># filter out low-gene cells (often empty wells)</span>
<span class="pl-smi">cd</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">cd</span>[, colSums(<span class="pl-smi">cd</span><span class="pl-k">&gt;</span><span class="pl-c1">0</span>)<span class="pl-k">&gt;</span><span class="pl-c1">1.8e3</span>]
<span class="pl-c"># remove genes that don't have many reads</span>
<span class="pl-smi">cd</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">cd</span>[rowSums(<span class="pl-smi">cd</span>)<span class="pl-k">&gt;</span><span class="pl-c1">10</span>, ]
<span class="pl-c"># remove genes that are not seen in a sufficient number of cells</span>
<span class="pl-smi">cd</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">cd</span>[rowSums(<span class="pl-smi">cd</span><span class="pl-k">&gt;</span><span class="pl-c1">0</span>)<span class="pl-k">&gt;</span><span class="pl-c1">5</span>, ]

<span class="pl-c"># transform to make more data normal</span>
<span class="pl-smi">mat</span> <span class="pl-k">&lt;-</span> log10(as.matrix(<span class="pl-smi">cd</span>)<span class="pl-k">+</span><span class="pl-c1">1</span>)
<span class="pl-c"># look at snippet of data</span>
<span class="pl-smi">mat</span>[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>]</pre></div>

<pre><code>##       Hi_NPC_1 Hi_NPC_10 Hi_NPC_14 Hi_NPC_15 Hi_NPC_13
## A1BG         0         0  1.477121  0.000000  2.243038
## A2M          0         0  1.079181  0.000000  1.806180
## A2MP1        0         0  0.000000  0.000000  0.000000
## AAAS         0         0  2.029384  2.262451  0.903090
## AACS         0         0  0.000000  2.068186  0.000000
</code></pre>

<p>For this dataset, the subpopulations group labels have also been provided to you as a reference so we can see how different methods perform in recapitulating these labels. </p>

<div class="highlight highlight-source-r"><pre>head(<span class="pl-smi">sg</span>, <span class="pl-c1">5</span>)</pre></div>

<pre><code>##  Hi_NPC_1 Hi_NPC_10 Hi_NPC_14 Hi_NPC_15 Hi_NPC_13 
##    group1    group1    group1    group1    group1 
## Levels: group1 group2 group3 group4
</code></pre>

<h1>
<a id="pca" class="anchor" href="#pca" aria-hidden="true"><span class="octicon octicon-link"></span></a>PCA</h1>

<p>Note that there are over 10,000 genes that can be used to cluster cells into subpopulations. One fast, easy, and common technique to identify subpopulations is by using dimensionality reduction to summarize the data into 2 dimensions and then visually identify obvious clusters. Principal component analysis is a linear dimensionality reduction method.</p>

<div class="highlight highlight-source-r"><pre>dim(<span class="pl-smi">mat</span>)</pre></div>

<pre><code>## [1] 11310    64
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># use principal component analysis for dimensionality reduction</span>
<span class="pl-smi">base.pca</span> <span class="pl-k">&lt;-</span> prcomp(t(<span class="pl-smi">mat</span>))
<span class="pl-c"># visualize in 2D the first two principal components and color by cell type</span>
<span class="pl-smi">sgCol</span> <span class="pl-k">&lt;-</span> rainbow(length(levels(<span class="pl-smi">sg</span>)))[<span class="pl-smi">sg</span>]
plot(<span class="pl-smi">base.pca</span><span class="pl-k">$</span><span class="pl-smi">x</span>[,<span class="pl-c1">1</span>], <span class="pl-smi">base.pca</span><span class="pl-k">$</span><span class="pl-smi">x</span>[,<span class="pl-c1">2</span>], <span class="pl-v">col</span><span class="pl-k">=</span><span class="pl-smi">sgCol</span>, <span class="pl-v">pch</span><span class="pl-k">=</span><span class="pl-c1">16</span>, <span class="pl-v">main</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>PCA<span class="pl-pds">'</span></span>)</pre></div>

<p><img src="figures/pca-1.png" alt="plot of chunk pca"> </p>

<p>Note that principal component analysis generally separates our subpopulations based on their expected group labels. However, cells do not segregate into obvious clusters. Furthermore, one of the main driving axis of variation here appears to be library size.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># scale to 1 to 100 range</span>
<span class="pl-smi">libSize</span> <span class="pl-k">&lt;-</span> colSums(<span class="pl-smi">cd</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) <span class="pl-c"># number of genes detected per cell as proxy</span>
<span class="pl-smi">libSize</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">libSize</span> <span class="pl-k">-</span> min(<span class="pl-smi">libSize</span>) <span class="pl-k">+</span> <span class="pl-c1">1</span>
<span class="pl-smi">libSize</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">libSize</span> <span class="pl-k">/</span> max(<span class="pl-smi">libSize</span>)
<span class="pl-smi">libSize</span> <span class="pl-k">&lt;-</span> round(<span class="pl-smi">libSize</span><span class="pl-k">*</span><span class="pl-c1">100</span>)
<span class="pl-c"># make red correspond to cells with more genes detected and blue to cells with less</span>
<span class="pl-smi">libCol</span> <span class="pl-k">&lt;-</span> colorRampPalette(c(<span class="pl-s"><span class="pl-pds">'</span>blue<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>yellow<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span>))(<span class="pl-c1">100</span>)[<span class="pl-smi">libSize</span>]
plot(<span class="pl-smi">base.pca</span><span class="pl-k">$</span><span class="pl-smi">x</span>[,<span class="pl-c1">1</span>], <span class="pl-smi">base.pca</span><span class="pl-k">$</span><span class="pl-smi">x</span>[,<span class="pl-c1">2</span>], <span class="pl-v">col</span><span class="pl-k">=</span><span class="pl-smi">libCol</span>, <span class="pl-v">pch</span><span class="pl-k">=</span><span class="pl-c1">16</span>, <span class="pl-v">main</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>PCA<span class="pl-pds">'</span></span>)</pre></div>

<p><img src="figures/pca2-1.png" alt="plot of chunk pca2"> </p>

<h1>
<a id="tsne" class="anchor" href="#tsne" aria-hidden="true"><span class="octicon octicon-link"></span></a>tSNE</h1>

<p>tSNE is a non-linear dimensionality reduction method. With tSNE, one group of cells do seem to segregate cleanly from the rest. If we did not have knowledge of the true group labels, we would be inclined to call this outgroup a subpopulation. </p>

<div class="highlight highlight-source-r"><pre>require(<span class="pl-smi">Rtsne</span>)
<span class="pl-smi">d</span> <span class="pl-k">&lt;-</span> <span class="pl-e">stats</span><span class="pl-k">::</span>dist(t(<span class="pl-smi">mat</span>))
set.seed(<span class="pl-c1">0</span>) <span class="pl-c"># tsne has some stochastic steps (gradient descent) so need to set random </span>
<span class="pl-smi">tsne_out</span> <span class="pl-k">&lt;-</span> Rtsne(<span class="pl-smi">d</span>, <span class="pl-v">is_distance</span><span class="pl-k">=</span><span class="pl-c1">TRUE</span>, <span class="pl-v">perplexity</span><span class="pl-k">=</span><span class="pl-c1">10</span>, <span class="pl-v">verbose</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>) 
plot(<span class="pl-smi">tsne_out</span><span class="pl-k">$</span><span class="pl-smi">Y</span>, <span class="pl-v">col</span><span class="pl-k">=</span><span class="pl-smi">sgCol</span>, <span class="pl-v">pch</span><span class="pl-k">=</span><span class="pl-c1">16</span>, <span class="pl-v">main</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>tSNE<span class="pl-pds">'</span></span>)</pre></div>

<p><img src="figures/tsne-1.png" alt="plot of chunk tsne"> </p>

<p>Still, we may be wondering what genes are driving this subpopulation? What genes or pathways characterize this subpopulation? For that, additional analysis is often needed and dimensionality reduction alone does not provide us with such insight. </p>

<h1>
<a id="hierarchical-clustering" class="anchor" href="#hierarchical-clustering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hierarchical clustering</h1>

<p>Standard hierarchical clustering uses genes to identify distinct classes of cells. In combination with a heatmap visualization, genes driving the hierarchical clustering can become readily apparent. However, most genes are not informative and contribute, at best, noise, resulting in an inaccurate clustering of cells.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># for the sake of speed, just select top 100 most variable genes</span>
<span class="pl-smi">v</span> <span class="pl-k">&lt;-</span> apply(<span class="pl-smi">mat</span>, <span class="pl-c1">1</span>, <span class="pl-smi">var</span>)
<span class="pl-smi">vi</span> <span class="pl-k">&lt;-</span> names(sort(<span class="pl-smi">v</span>)[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">100</span>])
<span class="pl-smi">hc</span> <span class="pl-k">&lt;-</span> hclust(dist(t(<span class="pl-smi">mat</span>[<span class="pl-smi">vi</span>,])))
<span class="pl-c"># visualize as heatmap</span>
heatmap(<span class="pl-smi">mat</span>[<span class="pl-smi">vi</span>,], <span class="pl-v">Rowv</span><span class="pl-k">=</span><span class="pl-c1">NA</span>, <span class="pl-v">Colv</span><span class="pl-k">=</span>as.dendrogram(<span class="pl-smi">hc</span>), <span class="pl-v">ColSideColors</span> <span class="pl-k">=</span> <span class="pl-smi">sgCol</span>,  <span class="pl-v">col</span><span class="pl-k">=</span>colorRampPalette(c(<span class="pl-s"><span class="pl-pds">'</span>blue<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>white<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span>))(<span class="pl-c1">100</span>))</pre></div>

<p><img src="figures/hclust-1.png" alt="plot of chunk hclust"> </p>

<h1>
<a id="backspin" class="anchor" href="#backspin" aria-hidden="true"><span class="octicon octicon-link"></span></a>BackSPIN</h1>

<p>Biclustering can be used to overcome this problem by simultaneously clustering genes and cells. <a href="http://www.sciencemag.org/content/347/6226/1138.full">BackSPIN</a> is an iterative, biclustering method based on sorting points into neighborhoods that can be used to cluster genes and cells to identify subpopulations as well as potential markers for each subpopulations. BackSPIN requires a particular CEF file as the input, so first, we will write out our data into that format.</p>

<div class="highlight highlight-source-r"><pre>write(<span class="pl-v">file</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>cd.cef<span class="pl-pds">"</span></span>, paste(<span class="pl-s"><span class="pl-pds">"</span>CEF<span class="pl-cce">\t</span>0<span class="pl-cce">\t</span>1<span class="pl-cce">\t</span>1<span class="pl-pds">"</span></span>, nrow(<span class="pl-smi">cd</span>), ncol(<span class="pl-smi">cd</span>), <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>, <span class="pl-v">sep</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>))
write(<span class="pl-v">file</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>cd.cef<span class="pl-pds">"</span></span>, paste(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\t</span><span class="pl-pds">'</span></span>, c(<span class="pl-s"><span class="pl-pds">"</span>cell<span class="pl-pds">"</span></span>), paste(colnames(<span class="pl-smi">cd</span>), <span class="pl-v">collapse</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>), <span class="pl-v">sep</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\t</span><span class="pl-pds">'</span></span>), <span class="pl-v">append</span><span class="pl-k">=</span><span class="pl-c1">T</span>)
<span class="pl-smi">x</span> <span class="pl-k">&lt;-</span> cbind(rep(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,nrow(<span class="pl-smi">cd</span>)), <span class="pl-smi">cd</span>)
write(<span class="pl-v">file</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>cd.cef<span class="pl-pds">"</span></span>, paste(c(<span class="pl-s"><span class="pl-pds">"</span>gene<span class="pl-pds">"</span></span>), <span class="pl-v">sep</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>), <span class="pl-v">append</span><span class="pl-k">=</span><span class="pl-c1">T</span>)
write.table(<span class="pl-v">file</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>cd.cef<span class="pl-pds">"</span></span>, <span class="pl-smi">x</span>, <span class="pl-v">append</span><span class="pl-k">=</span><span class="pl-c1">T</span>, <span class="pl-v">col.names</span><span class="pl-k">=</span><span class="pl-c1">F</span>, <span class="pl-v">row.names</span><span class="pl-k">=</span><span class="pl-c1">T</span>, <span class="pl-v">quote</span><span class="pl-k">=</span><span class="pl-c1">F</span>, <span class="pl-v">sep</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>)</pre></div>

<p>Now we can run BackSPIN by calling Python from within R.</p>

<div class="highlight highlight-source-r"><pre>system(<span class="pl-s"><span class="pl-pds">"</span>./BackSPIN-1.0/backSPIN.py -i cd.cef -o cd.clustered.cef -f 2000 -v -d 3<span class="pl-pds">"</span></span>)</pre></div>

<p>Now we can read the results back into R and visualize. We can note how BackSPIN first splits the red and green groups of cells from the blue and purple cells, and then proceeds to iteratively split within each of the identified groups.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">bsp.head</span> <span class="pl-k">&lt;-</span> read.delim(<span class="pl-s"><span class="pl-pds">"</span>cd.clustered.cef<span class="pl-pds">"</span></span>, <span class="pl-v">sep</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>, <span class="pl-v">stringsAsFactors</span><span class="pl-k">=</span><span class="pl-c1">F</span>, <span class="pl-v">nrows</span><span class="pl-k">=</span><span class="pl-c1">5</span>, <span class="pl-v">skip</span><span class="pl-k">=</span><span class="pl-c1">1</span>, <span class="pl-v">header</span><span class="pl-k">=</span><span class="pl-c1">F</span>)
<span class="pl-smi">bsp.lab</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">bsp.head</span>[<span class="pl-k">-</span>c(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>),<span class="pl-k">-</span>c(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">6</span>)]
colnames(<span class="pl-smi">bsp.lab</span>) <span class="pl-k">&lt;-</span> <span class="pl-smi">bsp.head</span>[<span class="pl-c1">1</span>,<span class="pl-k">-</span>c(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">6</span>)]
<span class="pl-smi">bsp.lab</span> <span class="pl-k">&lt;-</span> data.matrix(<span class="pl-smi">bsp.lab</span>)
<span class="pl-c"># color columns by group labels</span>
<span class="pl-smi">hc</span> <span class="pl-k">&lt;-</span> hclust(dist(t(<span class="pl-smi">bsp.lab</span>)))
heatmap(<span class="pl-smi">bsp.lab</span>, <span class="pl-v">Rowv</span><span class="pl-k">=</span><span class="pl-c1">NA</span>, <span class="pl-v">Colv</span><span class="pl-k">=</span>as.dendrogram(<span class="pl-smi">hc</span>), <span class="pl-v">ColSideColors</span> <span class="pl-k">=</span> <span class="pl-smi">sgCol</span>)</pre></div>

<p><img src="figures/backspin-1.png" alt="plot of chunk backspin"> </p>

<p>We can also assess what genes are driving these subpopulations.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">bsp.genes</span> <span class="pl-k">&lt;-</span> read.delim(<span class="pl-s"><span class="pl-pds">"</span>cd.clustered.cef<span class="pl-pds">"</span></span>,<span class="pl-v">stringsAsFactors</span><span class="pl-k">=</span><span class="pl-c1">F</span>,<span class="pl-v">sep</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>,<span class="pl-v">skip</span><span class="pl-k">=</span><span class="pl-c1">7</span>,<span class="pl-v">header</span><span class="pl-k">=</span><span class="pl-c1">T</span>)
<span class="pl-smi">bsp.sets</span> <span class="pl-k">&lt;-</span> unlist(apply(<span class="pl-smi">bsp.genes</span>[,c(<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>)],<span class="pl-c1">2</span>,<span class="pl-k">function</span>(<span class="pl-smi">x</span>) tapply(<span class="pl-smi">bsp.genes</span>[,<span class="pl-c1">1</span>],as.factor(<span class="pl-smi">x</span>),<span class="pl-smi">I</span>)),<span class="pl-v">recursive</span><span class="pl-k">=</span><span class="pl-c1">F</span>)
<span class="pl-c"># Look at one set</span>
<span class="pl-smi">genes</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">bsp.sets</span>[[<span class="pl-c1">1</span>]]
<span class="pl-c"># alternatively, uncomment to choose another gene set</span>
<span class="pl-c">#genes &lt;- bsp.sets[[2]]</span>
<span class="pl-c"># scale for better visualization</span>
<span class="pl-smi">m</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">mat</span>[<span class="pl-smi">genes</span>,]
<span class="pl-smi">m</span> <span class="pl-k">&lt;-</span> t(scale(t(<span class="pl-smi">m</span>)))
<span class="pl-smi">m</span>[<span class="pl-smi">m</span> <span class="pl-k">&lt;</span> <span class="pl-k">-</span><span class="pl-c1">2</span>] <span class="pl-k">&lt;-</span> <span class="pl-k">-</span><span class="pl-c1">2</span>
<span class="pl-smi">m</span>[<span class="pl-smi">m</span> <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>] <span class="pl-k">&lt;-</span> <span class="pl-c1">2</span>
heatmap(<span class="pl-smi">m</span>, <span class="pl-v">Rowv</span><span class="pl-k">=</span><span class="pl-c1">NA</span>, <span class="pl-v">Colv</span><span class="pl-k">=</span>as.dendrogram(<span class="pl-smi">hc</span>), <span class="pl-v">col</span><span class="pl-k">=</span>colorRampPalette(c(<span class="pl-s"><span class="pl-pds">'</span>blue<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>white<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span>))(<span class="pl-c1">100</span>), <span class="pl-v">ColSideColors</span> <span class="pl-k">=</span> <span class="pl-smi">sgCol</span>, <span class="pl-v">scale</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>none<span class="pl-pds">'</span></span>)</pre></div>

<p><img src="figures/backspin2-1.png" alt="plot of chunk backspin2"> </p>

<p>Interestingly, we can see how the green group of cells were separated into different subpopulations in the first split, although closer inspection of genes may suggest additional aspects of transcriptional heterogeneity that cut across this initial split. </p>

<h1>
<a id="pagoda" class="anchor" href="#pagoda" aria-hidden="true"><span class="octicon octicon-link"></span></a>PAGODA</h1>

<p><a href="http://biorxiv.org/content/early/2015/09/16/026948">PAGODA</a> is a method developed by the Kharchenko lab that enables identification and characterization of subpopulations in a manner that potentially resolves multiple overlapping aspects of transcriptional heterogeneity. </p>

<p>PAGODA routines are implemented within the SCDE R package. </p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># DO NOT EVALUATE</span>
<span class="pl-c"># This package has already been installed for you</span>
require(<span class="pl-smi">devtools</span>)
<span class="pl-e">devtools</span><span class="pl-k">::</span>install_github(<span class="pl-s"><span class="pl-pds">'</span>hms-dbmi/scde<span class="pl-pds">'</span></span>, <span class="pl-v">build_vignettes</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>)</pre></div>

<p>Error models are first fitted for each single cell. The purpose of the fitting is to model each cell as a mixture of two probabilistic processesâ€”one in which the transcript is amplified and detected at a level correlating with its abundance and the other in which a transcript fails to amplify or is not detected for other reasons (ie. dropout). In this manner, we can more robustly identify and distinguish drop-out events from true lack of expression. Additional details of the error modeling can be found in the original <a href="http://www.nature.com/nmeth/journal/v11/n7/pdf/nmeth.2967.pdf">SCDE manuscript</a>. </p>

<p>The fitting process relies on a subset of robust genes that are detected in multiple cross-cell comparisons. Due to the number of cross-cell comparisons, this step is fairly computationally intensive. For the purpose of example, we will compute error models for a small subset of 10 cells. </p>

<div class="highlight highlight-source-r"><pre>library(<span class="pl-smi">scde</span>)
<span class="pl-smi">knn</span> <span class="pl-k">&lt;-</span> knn.error.models(<span class="pl-smi">cd</span>[, <span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>], <span class="pl-v">k</span> <span class="pl-k">=</span> ncol(<span class="pl-smi">cd</span>)<span class="pl-k">/</span><span class="pl-c1">5</span>, <span class="pl-v">n.cores</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>, <span class="pl-v">min.count.threshold</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>, <span class="pl-v">min.nonfailed</span> <span class="pl-k">=</span> <span class="pl-c1">5</span>, <span class="pl-v">max.model.plots</span> <span class="pl-k">=</span> <span class="pl-c1">5</span>, <span class="pl-v">save.model.plots</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">verbose</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)  <span class="pl-c"># turn on verbosity</span></pre></div>

<pre><code>## cell : calculating cell-cell similarities ... done
</code></pre>

<div class="highlight highlight-source-r"><pre>head(<span class="pl-smi">knn</span>)</pre></div>

<pre><code>##             conc.b    conc.a    fail.r    corr.b corr.a corr.theta
## Hi_NPC_1  47.64973 -16.42042 -2.302585 0.9101083      1  0.1528216
## Hi_NPC_10 48.87006 -17.58194 -2.302585 0.9772399      1  0.1775833
## Hi_NPC_14 52.52041 -18.48200 -2.302585 0.5483105      1  0.1815323
## Hi_NPC_15 51.54416 -18.33884 -2.302585 1.0375941      1  0.1823398
## Hi_NPC_13 52.11990 -18.40302 -2.302585 0.9479813      1  0.1749775
## Hi_NPC_12 72.02597 -25.34845 -2.302585 0.4635859      1  0.2412035
##           corr.ltheta.b corr.ltheta.t corr.ltheta.m corr.ltheta.s
## Hi_NPC_1      -8.305691      2.914855      4.075386    -0.5057704
## Hi_NPC_10     -3.160282      3.288652      4.286077    -0.4124728
## Hi_NPC_14     -5.555386      3.250469      3.072089    -0.6740517
## Hi_NPC_15     -1.809298      2.844078      6.034755    -0.3642427
## Hi_NPC_13     -3.234334      2.591892      3.786538    -1.0339466
## Hi_NPC_12     -1.507832      3.344728      4.478469    -0.5397455
##           corr.ltheta.r  conc.a2
## Hi_NPC_1      0.1170947 1.468411
## Hi_NPC_10     0.4049705 1.630775
## Hi_NPC_14     0.1000000 1.685696
## Hi_NPC_15     1.4353150 1.681808
## Hi_NPC_13     0.1000000 1.674445
## Hi_NPC_12     0.7648221 2.291489
</code></pre>

<p>In the resulting summary table, <code>corr.a</code> and <code>corr.b</code> are slope and intersept of the correlated component fit, <code>conc.a</code> and <code>conc.b</code> are to the concomitant or associated fits, <code>corr.theta</code> is the NB over-dispersion, and <code>fail.r</code> is the background Poisson rate (fixed). We can also take a look at the resulting <code>cell.model.fits.pdf</code> file that is outputted to get a sense of how these parameters related to the data. </p>

<p><img src="figures/cell.model.fits.1.png" alt="sample cell model fit"> </p>

<p>The full set of error models for all cells has been precomputed for you and can be loaded.</p>

<div class="highlight highlight-source-r"><pre>load(<span class="pl-s"><span class="pl-pds">'</span>knn.RData<span class="pl-pds">'</span></span>)</pre></div>

<p>Particularly poor cells may result in abnormal fits, most commonly showing negtive <code>corr.a</code>, and should be removed.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># filter out cells that don't show positive correlation with</span>
<span class="pl-c"># the expected expression magnitudes (very poor fits)</span>
<span class="pl-smi">valid.cells</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">knn</span><span class="pl-k">$</span><span class="pl-smi">corr.a</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
table(<span class="pl-smi">valid.cells</span>)</pre></div>

<pre><code>## valid.cells
## TRUE 
##   64
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">knn</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">knn</span>[<span class="pl-smi">valid.cells</span>, ]</pre></div>

<p><code>PAGODA</code> relies on accurate quantification of excess variance or overdispersion in genes and gene sets in order to cluster cells and identify subpopulations. Accurate quantiification of this overdispersion means that we must normalize out expected levels of technical and intrinsic biological noise. Intuitively, lowly-expressed genes are often more prone to drop-out and thus may exhibit large variances simply due to such technical noise. </p>

<p>In <code>PAGODA</code>, variance of the NB/Poisson mixture processes derived from the error modeling step are modeled as a chi-squared distribution using adjusted degrees of freedom and observation weights based on the drop-out probability of a given gene. Additional details can be found in the <a href="http://biorxiv.org/content/early/2015/09/16/026948">PAGODA</a> manuscript. </p>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">varinfo</span> <span class="pl-k">&lt;-</span> pagoda.varnorm(<span class="pl-smi">knn</span>, <span class="pl-v">counts</span> <span class="pl-k">=</span> <span class="pl-smi">cd</span>, <span class="pl-v">trim</span> <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">/</span>ncol(<span class="pl-smi">cd</span>), <span class="pl-v">max.adj.var</span> <span class="pl-k">=</span> <span class="pl-c1">5</span>, <span class="pl-v">n.cores</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>, <span class="pl-v">plot</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>)</pre></div>

<p><img src="figures/varnorm-1.png" alt="plot of chunk varnorm"> </p>

<p>Sequencing depth or gene coverage is typically still a major aspects of variability, as we have seen previously in our PCA analysis. We can control for the gene coverage (estimated as a number of genes with non-zero magnitude per cell) and normalize out that aspect of cell heterogeneity.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">varinfo</span> <span class="pl-k">&lt;-</span> pagoda.subtract.aspect(<span class="pl-smi">varinfo</span>, colSums(<span class="pl-smi">cd</span>[, rownames(<span class="pl-smi">knn</span>)]<span class="pl-k">&gt;</span><span class="pl-c1">0</span>))</pre></div>

<p>We assess for overdispersion in gene sets, we can take advantage of pre-defined pathway gene sets such as GO annotations and look for pathways that exhibit statistically significant excess of coordinated variability. Intuitively, if a pathway is differentially perturbed, we expect all genes within said pathway to be upregulated or downregulated in the same group of cells. In <code>PAGODA</code>, for each gene set, we tested whether the amount of variance explained by the first principal component significantly exceed the background expectation.</p>

<p>A set of GO terms has been pre-defined for you and can be loaded.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># DO NOT EVALUATE</span>
<span class="pl-c"># code is provided to show you how the GO terms were derived</span>

library(<span class="pl-smi">org.Hs.eg.db</span>)
<span class="pl-c"># translate gene names to ids</span>
<span class="pl-smi">ids</span> <span class="pl-k">&lt;-</span> unlist(lapply(mget(rownames(<span class="pl-smi">cd</span>), <span class="pl-smi">org.Hs.egALIAS2EG</span>, <span class="pl-v">ifnotfound</span> <span class="pl-k">=</span> <span class="pl-c1">NA</span>), <span class="pl-k">function</span>(<span class="pl-smi">x</span>) <span class="pl-smi">x</span>[<span class="pl-c1">1</span>]))
<span class="pl-c"># reverse map</span>
<span class="pl-smi">rids</span> <span class="pl-k">&lt;-</span> names(<span class="pl-smi">ids</span>)
names(<span class="pl-smi">rids</span>) <span class="pl-k">&lt;-</span> <span class="pl-smi">ids</span>
<span class="pl-c"># list all the ids per GO category</span>
<span class="pl-smi">go.env</span> <span class="pl-k">&lt;-</span> eapply(<span class="pl-smi">org.Hs.egGO2ALLEGS</span>, <span class="pl-k">function</span>(<span class="pl-smi">x</span>) as.character(na.omit(<span class="pl-smi">rids</span>[<span class="pl-smi">x</span>])))
<span class="pl-c"># omit categories with too few genes</span>
<span class="pl-smi">go.env</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">go.env</span>[unlist(lapply(<span class="pl-smi">go.env</span>, <span class="pl-smi">length</span>))<span class="pl-k">&gt;</span><span class="pl-c1">5</span>]

<span class="pl-c"># append descriptions to the GO names</span>
library(<span class="pl-smi">GO.db</span>)
<span class="pl-smi">desc</span> <span class="pl-k">&lt;-</span> unlist(lapply(mget(names(<span class="pl-smi">go.env</span>), <span class="pl-smi">GOTERM</span>, <span class="pl-v">ifnotfound</span> <span class="pl-k">=</span> <span class="pl-c1">NA</span>), <span class="pl-k">function</span>(<span class="pl-smi">x</span>) <span class="pl-k">if</span>(is.logical(<span class="pl-smi">x</span>)) { <span class="pl-k">return</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>) } <span class="pl-k">else</span> { slot(<span class="pl-smi">x</span>, <span class="pl-s"><span class="pl-pds">"</span>Term<span class="pl-pds">"</span></span>)}))
names(<span class="pl-smi">go.env</span>) <span class="pl-k">&lt;-</span> paste(names(<span class="pl-smi">go.env</span>), <span class="pl-smi">desc</span>)  <span class="pl-c"># append description to the names</span>
<span class="pl-c"># convert to an environment</span>
<span class="pl-smi">go.env</span> <span class="pl-k">&lt;-</span> list2env(<span class="pl-smi">go.env</span>)  </pre></div>

<div class="highlight highlight-source-r"><pre>load(<span class="pl-s"><span class="pl-pds">'</span>go.env.RData<span class="pl-pds">'</span></span>)
<span class="pl-c"># pathway overdispersion</span>
<span class="pl-smi">pwpca</span> <span class="pl-k">&lt;-</span> pagoda.pathway.wPCA(<span class="pl-smi">varinfo</span>, <span class="pl-smi">go.env</span>, <span class="pl-v">n.components</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-v">n.cores</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>, <span class="pl-v">n.internal.shuffles</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>)</pre></div>

<p>Instead of relying on pre-defined pathways, we can also test on 'de novo' gene sets whose expression profiles are well-correlated within the given dataset.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># de novo gene sets</span>
<span class="pl-smi">clpca</span> <span class="pl-k">&lt;-</span> pagoda.gene.clusters(<span class="pl-smi">varinfo</span>, <span class="pl-v">trim</span> <span class="pl-k">=</span> <span class="pl-c1">7.1</span><span class="pl-k">/</span>ncol(<span class="pl-smi">varinfo</span><span class="pl-k">$</span><span class="pl-smi">mat</span>), <span class="pl-v">n.clusters</span> <span class="pl-k">=</span> <span class="pl-c1">150</span>, <span class="pl-v">n.cores</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>, <span class="pl-v">plot</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>)</pre></div>

<p>Testing these pre-defined pathways and annotated gene sets may take a few minutes. If you are having trouble keeping up, you can load a pre-computed version.</p>

<div class="highlight highlight-source-r"><pre>load(<span class="pl-s"><span class="pl-pds">'</span>clusters.RData<span class="pl-pds">'</span></span>)</pre></div>

<p>Taking into consideration both pre-defined pathways and de-novo gene sets, we can see which aspects of heterogeneity are the most overdispersed and base our cell cluster only on the most overdispersed and informative pathways and gene sets. </p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># get full info on the top aspects</span>
<span class="pl-smi">df</span> <span class="pl-k">&lt;-</span> pagoda.top.aspects(<span class="pl-smi">pwpca</span>, <span class="pl-smi">clpca</span>, <span class="pl-v">z.score</span> <span class="pl-k">=</span> <span class="pl-c1">1.96</span>, <span class="pl-k">return</span><span class="pl-v">.table</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>)
head(<span class="pl-smi">df</span>)</pre></div>

<pre><code>##                                                                     name
## 5556                                                       geneCluster.7
## 447                                   GO:0003170 heart valve development
## 448                                 GO:0003179 heart valve morphogenesis
## 452                           GO:0003208 cardiac ventricle morphogenesis
## 2149    GO:0021952 central nervous system projection neuron axonogenesis
## 4507 GO:0060045 positive regulation of cardiac muscle cell proliferation
##      npc   n    score        z     adj.z sh.z adj.sh.z
## 5556   1 278 3.954466 15.93746 15.621175   NA       NA
## 447    1  14 2.987632 10.17247  9.850132   NA       NA
## 448    1  14 2.987632 10.17247  9.850132   NA       NA
## 452    1  27 2.798583 11.41449 11.091890   NA       NA
## 2149   1  20 2.644643  9.67749  9.357735   NA       NA
## 4507   1  11 2.635690  8.03415  7.701229   NA       NA
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">tam</span> <span class="pl-k">&lt;-</span> pagoda.top.aspects(<span class="pl-smi">pwpca</span>, <span class="pl-smi">clpca</span>, <span class="pl-v">z.score</span> <span class="pl-k">=</span> qnorm(<span class="pl-c1">0.01</span><span class="pl-k">/</span><span class="pl-c1">2</span>, <span class="pl-v">lower.tail</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>))
<span class="pl-c"># determine overall cell clustering</span>
<span class="pl-smi">hc</span> <span class="pl-k">&lt;-</span> pagoda.cluster.cells(<span class="pl-smi">tam</span>, <span class="pl-smi">varinfo</span>)</pre></div>

<p>Because many of our annotated pathways and de novo gene sets likely share many genes or exhibit similarpatterns of variability, we must reduce such redundancy. First, we will combine pathways that are driven by the same sets of genes.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># reduce redundant aspects</span>
<span class="pl-smi">tamr</span> <span class="pl-k">&lt;-</span> pagoda.reduce.loading.redundancy(<span class="pl-smi">tam</span>, <span class="pl-smi">pwpca</span>, <span class="pl-smi">clpca</span>)</pre></div>

<p>Next, we will combine aspects that show similar patterns (i.e. separate the same sets of cells). In the following heatmap, the columns are cells, rows are different significant aspects, clustered by their similarity pattern.The green-to-orange color scheme shows low-to-high weighted PCA scores (aspect patterns), where generally orange indicates higher expression. We can see how redundant aspects are clustered together. </p>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">tamr2</span> <span class="pl-k">&lt;-</span> pagoda.reduce.redundancy(<span class="pl-smi">tamr</span>, <span class="pl-v">distance.threshold</span> <span class="pl-k">=</span> <span class="pl-c1">0.5</span>, <span class="pl-v">plot</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">cell.clustering</span> <span class="pl-k">=</span> <span class="pl-smi">hc</span>, <span class="pl-v">labRow</span> <span class="pl-k">=</span> <span class="pl-c1">NA</span>, <span class="pl-v">labCol</span> <span class="pl-k">=</span> <span class="pl-c1">NA</span>, <span class="pl-v">box</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">margins</span> <span class="pl-k">=</span> c(<span class="pl-c1">0.5</span>, <span class="pl-c1">0.5</span>), <span class="pl-v">trim</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>)</pre></div>

<p><img src="figures/tamr-1.png" alt="plot of chunk tamr"> </p>

<p>Now we can view the final result as a heatmap where each row here represents a cluster of pathways where the row names are assigned to be the top overdispersed aspect in each cluster.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># view final result</span>
pagoda.view.aspects(<span class="pl-smi">tamr2</span>, <span class="pl-v">cell.clustering</span> <span class="pl-k">=</span> <span class="pl-smi">hc</span>, <span class="pl-v">box</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">labCol</span> <span class="pl-k">=</span> <span class="pl-c1">NA</span>, <span class="pl-v">margins</span> <span class="pl-k">=</span> c(<span class="pl-c1">0.5</span>, <span class="pl-c1">20</span>), <span class="pl-v">col.cols</span> <span class="pl-k">=</span> <span class="pl-smi">sgCol</span>)</pre></div>

<p><img src="figures/pagoda-1.png" alt="plot of chunk pagoda"> </p>

<p>We can also create an app to interactively browse the results.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># compile a browsable app, showing top three clusters with the top color bar</span>
<span class="pl-smi">app</span> <span class="pl-k">&lt;-</span> make.pagoda.app(<span class="pl-smi">tamr2</span>, <span class="pl-smi">tam</span>, <span class="pl-smi">varinfo</span>, <span class="pl-smi">go.env</span>, <span class="pl-smi">pwpca</span>, <span class="pl-smi">clpca</span>, <span class="pl-v">col.cols</span> <span class="pl-k">=</span> <span class="pl-smi">col.cols</span>, <span class="pl-v">cell.clustering</span> <span class="pl-k">=</span> <span class="pl-smi">hc</span>, <span class="pl-v">title</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>NPCs<span class="pl-pds">"</span></span>)
<span class="pl-c"># show app in the browser (port 1468)</span>
show.app(<span class="pl-smi">app</span>, <span class="pl-s"><span class="pl-pds">"</span>pollen<span class="pl-pds">"</span></span>, <span class="pl-v">browse</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">port</span> <span class="pl-k">=</span> <span class="pl-c1">1468</span>)  </pre></div>

<p>Again, we recapitulate the split between the red and green groups of cells from the blue and purple cells. Based on the associated pathways, we can see that this split is being driven by genes and processes related to 'neuron differentiation' and 'cell proliferation'. Interestingly, the component of transcriptional heterogeneity that is captured by the green group of cells is characterized by a 'de novo' gene cluste 40. In this manner, we can see how additional, overlapping aspects of transcriptional heterogeneity may exist in our data and be made evident by <code>PAGODA</code>.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/JEFworks">JEFworks</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
